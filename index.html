<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#3b82f6">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="AI広告台本">
    <title>AI動画広告ジェネレーター (セリフ色分け版)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Libraries for file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.18/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #file-preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
        }
        .thumbnail {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 0.5rem;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 0.5rem;
            text-align: center;
            background-color: #f9fafb;
        }
        .thumbnail span {
            font-size: 0.75rem;
            word-break: break-all;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        #result-image-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #000;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        #result-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: opacity 0.5s linear;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AI動画広告ジェネレーター</h1>
            <p class="text-gray-600 mt-2">画像やURLから、AIが広告用の掛け合い台本を自動作成します。</p>
        </header>

        <main class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
            <!-- Mode Selection -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-2xl font-bold">ステップ1：素材を選択</h2>
                    <button id="import-csv-btn" class="bg-indigo-100 text-indigo-700 font-semibold py-2 px-4 rounded-lg hover:bg-indigo-200 transition-all text-sm">
                        CSVインポート
                    </button>
                    <input type="file" id="csv-import-input" class="hidden" accept=".csv">
                </div>
                <div class="flex gap-4" id="mode-selector">
                    <label class="flex items-center gap-2 p-3 border rounded-lg cursor-pointer flex-1">
                        <input type="radio" name="mode" value="file" checked class="form-radio h-5 w-5 text-blue-600">
                        <span>ファイルから作成</span>
                    </label>
                    <label class="flex items-center gap-2 p-3 border rounded-lg cursor-pointer flex-1">
                        <input type="radio" name="mode" value="url" class="form-radio h-5 w-5 text-blue-600">
                        <span>URLから作成</span>
                    </label>
                </div>
            </div>

            <!-- File Input Section -->
            <div id="file-input-section">
                 <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-bold">ファイルをアップロード（複数可）</h3>
                    <button id="clear-files-btn" class="text-sm font-semibold text-red-600 hover:text-red-800 hidden">&times; すべてクリア</button>
                </div>
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer hover:bg-gray-50" id="drop-zone">
                    <input type="file" id="file-upload" accept="image/*,.pdf,.docx,.xlsx" class="hidden" multiple>
                    <p id="upload-prompt">ここにファイル（画像, PDF, Word, Excel）をドラッグ＆ドロップするか、クリックして選択</p>
                    <div id="file-preview-container"></div>
                </div>
            </div>
            
            <!-- URL Input Section -->
            <div id="url-input-section" class="hidden">
                 <h3 class="text-xl font-bold mb-2">URLを入力</h3>
                 <input type="url" id="url-input" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="https://example.com">
            </div>

            <!-- Step 2: 何を作るか -->
            <div class="mt-8 mb-8">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">ステップ2：何を作りますか？</h2>
                <div class="flex gap-4 mb-6">
                    <label class="flex items-center gap-2 p-4 border-2 rounded-lg cursor-pointer flex-1 hover:bg-blue-50 border-blue-200 has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                        <input type="radio" name="output-mode" value="voice" checked class="form-radio h-5 w-5 text-blue-600">
                        <span class="font-semibold">音声を作る</span>
                        <span class="text-sm text-gray-500">台本を生成し、音声で再生・ダウンロード</span>
                    </label>
                    <label class="flex items-center gap-2 p-4 border-2 rounded-lg cursor-pointer flex-1 hover:bg-amber-50 border-amber-200 has-[:checked]:border-amber-500 has-[:checked]:bg-amber-50">
                        <input type="radio" name="output-mode" value="poster" class="form-radio h-5 w-5 text-amber-600">
                        <span class="font-semibold">ポスターを作る</span>
                        <span class="text-sm text-gray-500">画像を生成し、ポスターとしてダウンロード</span>
                    </label>
                </div>
            </div>

            <!-- Voice flow: Step 2 scenario + Step 3 + Generate -->
            <div id="voice-flow" class="mt-8 mb-8">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">台本の雰囲気と形式</h2>
                <div class="mb-4">
                    <label class="block mb-2 font-semibold text-gray-700">雰囲気や形式を選択（複数可）:</label>
                    <div id="scenario-checkboxes" class="grid grid-cols-2 md:grid-cols-4 gap-2">
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="元気な後輩と落ち着いた先輩の対話形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>後輩と先輩の対話</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="専門家が初心者に解説する形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>専門家による解説</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="ニュースキャスターが紹介する形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>ニュース風の紹介</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="友人同士が感想を語り合う形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>友人同士の会話</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="ユーモアを交えて面白く" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>ユーモアを交える</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="本部社員とアルバイトの会話" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>社員とバイトの会話</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="最後にオチをつける" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>オチをつける</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="サンドイッチマン風の漫才形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>サンドイッチマン風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="ナイツ風の漫才形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>ナイツ風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="博多華丸・大吉風の漫才形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>花丸大吉風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="中川家風の漫才形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>中川家風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="関西弁で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>関西弁</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="オードリー風の漫才形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>オードリー風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="古舘伊知郎さん風の実況形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>古舘伊知郎風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="彦麻呂さん風の食レポ形式で" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>彦麻呂風</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="賑やかな感じで" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>賑やかな感じで</span>
                        </label>
                         <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="1分以内で短くまとめる" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>1分でまとめる</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="3分程度でまとめる" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>3分でまとめる</span>
                        </label>
                    </div>
                </div>
                 <div>
                    <label for="speaker-count" class="block mb-2 font-semibold text-gray-700">話者の人数:</label>
                    <input type="number" id="speaker-count" value="2" min="1" max="5" class="w-24 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                </div>
            </div>

            <!-- Step 3: Specific Instructions (New) -->
            <div class="mt-8 mb-8">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">ステップ3：アピールポイントと具体的な指示</h2>
                <div class="mb-4">
                    <label class="block mb-2 font-semibold text-gray-700">具体的な訴求点を選択（複数選択可）:</label>
                    <div id="appeal-checkboxes" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50 bg-amber-50/30 border-amber-200">
                            <input type="checkbox" value="新商品であることをアピールして" class="form-checkbox h-5 w-5 text-amber-600">
                            <span class="font-medium text-amber-900">新商品をアピール</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50 bg-amber-50/30 border-amber-200">
                            <input type="checkbox" value="価格の安さやお得感（プライス）をしっかり強調して" class="form-checkbox h-5 w-5 text-amber-600">
                            <span class="font-medium text-amber-900">価格・お得感を強調</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-green-50 bg-green-50/30 border-green-200">
                            <input type="checkbox" value="1つ買うと1つもらえる「プライチ」キャンペーンであることをしっかりと訴求して" class="form-checkbox h-5 w-5 text-green-600">
                            <span class="font-medium text-green-900">プライチ（1個買うと1個無料）</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-red-50 bg-red-50/30 border-red-200">
                            <input type="checkbox" value="粗利や原価に関する内部情報は絶対に台本に含めないで" class="form-checkbox h-5 w-5 text-red-600">
                            <span class="font-medium text-red-900">粗利・原価は含めない</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50 bg-amber-50/30 border-amber-200">
                            <input type="checkbox" value="期間限定・今だけのチャンスであることを強調して" class="form-checkbox h-5 w-5 text-amber-600">
                            <span class="font-medium text-amber-900">期間限定を強調</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="SNSでの評判や口コミ情報を交えて紹介して" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>口コミ・SNS反応</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="メーカー公式サイトの情報も盛り込んで説明して" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>メーカー公式情報</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="公的機関のデータや情報を引用して信頼性を高めて" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>公的データ・信頼性</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="ターゲット層（初心者、主婦など）に呼びかける表現を入れて" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>ターゲットへの呼掛</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="他社製品との違いやメリットを際立たせて" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>他社との差別化</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="特典やキャンペーン情報を強調して" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>特典・キャンペーン</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="商品の使い方を具体的にイメージさせて" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>使い方のイメージ</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="checkbox" value="お客様の悩みに寄り添い、解決策として提示して" class="form-checkbox h-5 w-5 text-blue-600">
                            <span>悩み解決の提示</span>
                        </label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-red-50 bg-red-50/30 border-red-200">
                            <input type="checkbox" value="最後に「検索」や「クリック」を強く促して" class="form-checkbox h-5 w-5 text-red-600">
                            <span class="font-medium text-red-900">検索・クリックを促す</span>
                        </label>
                    </div>
                </div>
                <div class="mb-4">
                    <label for="scenario-detail" class="block mb-2 font-semibold text-gray-700">その他の自由記述（具体的な要望があれば）:</label>
                    <textarea id="scenario-detail" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" rows="2" placeholder="例：〇〇というキャラクターも登場させてください。特に「安心感」を重視してください。"></textarea>
                </div>
            </div>

            <!-- Generate Button (Voice) -->
            <div class="text-center">
                <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-all shadow-md text-lg disabled:bg-gray-400 disabled:cursor-not-allowed">
                    広告素材を生成
                </button>
            </div>
            </div>

            <!-- Poster flow -->
            <div id="poster-flow" class="mt-8 mb-8 hidden">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">ポスターの設定</h2>
                <div class="mb-4">
                    <label class="block mb-2 font-semibold text-gray-700">トーン・マナー（複数可）:</label>
                    <div id="poster-tone-checkboxes" class="grid grid-cols-2 md:grid-cols-4 gap-2">
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="フォーマルで上品な" class="form-checkbox text-amber-600"><span>フォーマル</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="カジュアルで親しみやすい" class="form-checkbox text-amber-600"><span>カジュアル</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="プロフェッショナルで信頼感のある" class="form-checkbox text-amber-600"><span>プロフェッショナル</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="ポップで明るい" class="form-checkbox text-amber-600"><span>ポップ</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="落ち着いた雰囲気の" class="form-checkbox text-amber-600"><span>落ち着いた</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="元気で活力のある" class="form-checkbox text-amber-600"><span>元気</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="高級感のある" class="form-checkbox text-amber-600"><span>高級感</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="シンプルでミニマルな" class="form-checkbox text-amber-600"><span>シンプル</span></label>
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block mb-2 font-semibold text-gray-700">強調したいこと（複数可）:</label>
                    <div id="poster-emphasis-checkboxes" class="grid grid-cols-2 md:grid-cols-4 gap-2">
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="新商品・新サービス" class="form-checkbox text-amber-600"><span>新商品</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="価格・お得感" class="form-checkbox text-amber-600"><span>価格</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="期間限定" class="form-checkbox text-amber-600"><span>期間限定</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="品質・こだわり" class="form-checkbox text-amber-600"><span>品質</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="ブランド・信頼" class="form-checkbox text-amber-600"><span>ブランド</span></label>
                        <label class="flex items-center gap-2 p-2 border rounded-lg cursor-pointer hover:bg-amber-50"><input type="checkbox" value="キャンペーン・特典" class="form-checkbox text-amber-600"><span>キャンペーン</span></label>
                    </div>
                </div>
                <div class="mb-4">
                    <label for="poster-size" class="block mb-2 font-semibold text-gray-700">出力サイズ:</label>
                    <select id="poster-size" class="p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 transition">
                        <option value="3:4">A4縦 (3:4)</option>
                        <option value="4:3">A4横 (4:3)</option>
                        <option value="2:3">A3縦 (2:3)</option>
                        <option value="3:2">A3横 (3:2)</option>
                        <option value="1:1">1:1 (SNS・正方形)</option>
                        <option value="16:9">16:9 (横長)</option>
                        <option value="9:16">9:16 (縦長)</option>
                    </select>
                </div>
                <div class="text-center">
                    <button id="generate-poster-btn" class="bg-amber-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-amber-600 transition-all shadow-md text-lg disabled:bg-gray-400 disabled:cursor-not-allowed">
                        ポスターを生成
                    </button>
                </div>
            </div>

            <!-- Loading Indicator -->
            <div id="loading" class="hidden flex-col items-center justify-center my-8">
                <div class="loader"></div>
                <p id="loading-text" class="mt-4 text-gray-600">AIが台本を生成中です... (約30秒かかります)</p>
            </div>

            <!-- Result Section -->
            <div id="result-section" class="hidden mt-10">
                <h2 class="text-2xl font-bold mb-6 text-center">🎉 広告素材が完成しました！ 🎉</h2>
                
                <div class="bg-gray-50 p-6 rounded-lg">
                    <div id="result-image-container" class="hidden">
                        <img id="result-image" alt="広告画像">
                    </div>
                    <p id="image-counter" class="text-center text-gray-500 text-sm mt-2"></p>
                    <div class="mt-4">
                        <div id="voice-settings-container" class="mb-4 p-4 border rounded-lg bg-white">
                             <h3 class="text-xl font-bold mb-3">話者の設定</h3>
                             <div class="mb-4 p-3 bg-gray-50 rounded-lg">
                                 <p class="font-semibold text-gray-700 mb-2">音声エンジン</p>
                                 <div class="flex flex-wrap items-center gap-4">
                                     <label class="flex items-center gap-2 cursor-pointer">
                                         <input type="radio" name="voice-engine" value="browser" checked class="form-radio text-blue-600">
                                         <span>ブラウザの音声</span>
                                     </label>
                                     <label class="flex items-center gap-2 cursor-pointer">
                                         <input type="radio" name="voice-engine" value="voicevox" class="form-radio text-blue-600">
                                         <span>VOICEVOX（ずんだもん等）</span>
                                     </label>
                                     <span id="voicevox-status" class="text-sm text-gray-500 hidden"></span>
                                 </div>
                                 <div id="voicevox-url-row" class="mt-2 hidden">
                                     <label class="text-sm text-gray-600">VOICEVOX Engine URL（通常はそのままでOK）:</label>
                                     <input type="text" id="voicevox-engine-url" value="http://localhost:50021" class="mt-1 w-full max-w-md p-2 border border-gray-300 rounded text-sm">
                                 </div>
                             </div>
                             <div id="voice-selectors" class="space-y-2"></div>
                        </div>
                        <h3 class="text-xl font-bold mb-3">生成された台本（編集可能）</h3>
                        <p class="text-sm text-gray-600 mb-2">任意の位置に「下にセリフ」で行を挿入し、キャラ名とセリフを入力するとそのメンバーが読み上げます。不要な行は「削除」で消せます。</p>
                        <div id="script-editor" class="w-full p-3 border border-gray-300 rounded-lg bg-white space-y-2"></div>
                        <div class="mt-4 p-4 border rounded-lg bg-white">
                             <h3 class="text-xl font-bold mb-3">ツール</h3>
                             <div class="flex items-center gap-4 mb-4">
                                <select id="translate-language" class="w-full p-2 border rounded-md bg-white">
                                    <option value="English">英語</option>
                                    <option value="Chinese">中国語</option>
                                    <option value="Korean">韓国語</option>
                                    <option value="Spanish">スペイン語</option>
                                    <option value="French">フランス語</option>
                                    <option value="Vietnamese">ベトナム語</option>
                                </select>
                                <button id="translate-btn" class="bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-700 transition-all text-sm flex-shrink-0">翻訳を実行</button>
                             </div>
                             <div class="flex flex-wrap gap-4">
                                <button id="play-full-ad-btn" class="flex-1 min-w-[140px] bg-green-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-600 transition-all shadow-md flex items-center justify-center text-lg">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                                    ここから再生
                                </button>
                                <button id="download-full-audio-btn" class="flex-1 min-w-[140px] bg-emerald-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-emerald-700 transition-all shadow-md flex items-center justify-center text-lg">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>
                                    音声をまとめてダウンロード
                                </button>
                                <button id="export-csv-btn" class="flex-1 min-w-[140px] bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-600 transition-all shadow-md flex items-center justify-center text-lg">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                    CSVエクスポート
                                </button>
                            </div>
                            <!-- BGMを付けてダウンロード -->
                            <div id="bgm-download-section" class="mt-4 p-4 border border-gray-200 rounded-lg bg-gray-50">
                                <h4 class="font-bold text-gray-800 mb-3">BGMを付けてダウンロード</h4>
                                <p class="text-sm text-gray-600 mb-3">VOICEVOXで作った音声にBGMを混ぜて1本のWAVで保存できます。BGMは音声が長い間ループ再生され、音声の終わりに合わせてフェードアウトします。</p>
                                <div class="flex flex-wrap items-end gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">BGMファイル（MP3/WAV）</label>
                                        <input type="file" id="bgm-file-input" accept="audio/*" class="hidden">
                                        <button type="button" id="bgm-file-select-btn" class="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm">ファイルを選択</button>
                                        <span id="bgm-file-name" class="ml-2 text-sm text-gray-500">未選択</span>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">BGMの音量 <span id="bgm-volume-value">15</span>%</label>
                                        <input type="range" id="bgm-volume-slider" min="0" max="50" value="15" class="w-32">
                                    </div>
                                    <button type="button" id="download-with-bgm-btn" class="px-4 py-2 bg-amber-500 text-white font-bold rounded-lg hover:bg-amber-600 transition-all shadow flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>
                                        BGMを付けてダウンロード
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- VOICEVOX 利用時 -->
                <div class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <h3 class="text-xl font-bold mb-3 text-blue-900">VOICEVOX（ずんだもん等）を使う場合</h3>
                    <p class="font-semibold text-blue-900 mb-2">「同じPCでエンジンを起動する」とは：</p>
                    <ol class="list-decimal list-inside text-blue-800 space-y-2 text-sm mb-3">
                        <li><strong>VOICEVOX</strong> を <a href="https://voicevox.hiroshiba.jp/" target="_blank" rel="noopener" class="underline">公式サイト（voicevox.hiroshiba.jp）</a> からダウンロードし、Mac にインストールします。</li>
                        <li>アプリケーションから <strong>VOICEVOX</strong> を起動し、ウィンドウを開いたままにします（バックグラウンドで動いていればOK）。</li>
                        <li>この状態で、このアプリ（<strong>http://localhost:9000</strong> など）を<strong>同じ Mac</strong> のブラウザで開き、「音声エンジン」で <strong>VOICEVOX</strong> を選ぶと、ずんだもん等の声で再生できます。</li>
                    </ol>
                    <p class="text-blue-800 text-sm">※ VOICEVOX を起動すると、内部で Engine がポート 50021 で待ち受けます。別の PC でこのアプリを開いていると接続できないため、「同じPC（同じMac）で」VOICEVOX を起動する必要があります。</p>
                </div>

                <!-- Export Instructions -->
                <div class="mt-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                    <h3 class="text-xl font-bold mb-3 text-amber-900">音声付き動画の保存方法 (Mac)</h3>
                    <ol class="list-decimal list-inside text-amber-800 space-y-2">
                        <li>キーボードで <strong>「command」+「shift」+「5」</strong>を同時に押します。</li>
                        <li>表示されたツールバーで**「画面全体を収録」**を選び、**「収録」**ボタンを押します。</li>
                        <li>すぐに、このアプリの**「広告全体を再生」**ボタンを押します。</li>
                        <li>広告の再生が終わったら、画面上部の■（停止）ボタンを押して収録を終了します。デスクトップに動画ファイルが保存されます。</li>
                    </ol>
                </div>

                <!-- アプリの仕様 -->
                <div class="mt-6 p-4 bg-slate-50 border border-slate-200 rounded-lg">
                    <button type="button" id="spec-toggle-btn" class="w-full text-left flex items-center justify-between font-bold text-slate-800 text-lg">
                        <span>アプリの仕様</span>
                        <span id="spec-toggle-icon" class="text-slate-500">▼</span>
                    </button>
                    <div id="spec-content" class="hidden mt-4 text-sm text-slate-700 space-y-4">
                        <section>
                            <h4 class="font-bold text-slate-800 mb-1">概要</h4>
                            <p>画像・URL・ファイルからAI（Gemini）で台本を生成し、ブラウザ音声またはVOICEVOXで再生。CSV入出力・翻訳・行単位/全体の音声ダウンロード・BGM付きダウンロードに対応。</p>
                        </section>
                        <section>
                            <h4 class="font-bold text-slate-800 mb-1">台本編集</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>「下にセリフ」：その行の直下にセリフ行を挿入（キャラ名・セリフを入力するとそのメンバーが読み上げ）。</li>
                                <li>「行を追加」：末尾にセリフ行を追加。</li>
                                <li>「削除」：その行を削除（最後の1行は削除不可）。</li>
                                <li>キャラ名は話者の設定に合わせると、その声で再生される。</li>
                            </ul>
                        </section>
                        <section>
                            <h4 class="font-bold text-slate-800 mb-1">音声</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>ブラウザの音声：台本のキャラごとにブラウザの日本語音声を選択可能。</li>
                                <li>VOICEVOX：同じPCでVOICEVOX Engine（localhost:50021）を起動し、http://localhost:9000 でアプリを開いた場合に利用可能。オンライン（HTTPS）で開いた場合はVOICEVOXは使えない。</li>
                                <li>音声をまとめてダウンロード：VOICEVOX選択時、全行を1本のWAVでダウンロード。</li>
                                <li>BGMを付けてダウンロード：VOICEVOX音声にBGMファイルを混ぜてダウンロード。BGMはループし、音声の終わりでフェードアウト。</li>
                            </ul>
                        </section>
                        <section>
                            <h4 class="font-bold text-slate-800 mb-1">API・データ</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Gemini APIキー：画面上で入力・保存（localStorage）。台本生成・翻訳に使用。</li>
                                <li>CSV：インポート（character,line形式）・エクスポート対応。</li>
                            </ul>
                        </section>
                        <section>
                            <h4 class="font-bold text-slate-800 mb-1">PWA</h4>
                            <p>インストール可能。常に最新版で開くため、Service Workerでネットワーク優先・更新時リロードを実施。</p>
                        </section>
                    </div>
                </div>
            </div>

            <!-- Poster Result Section -->
            <div id="result-section-poster" class="hidden mt-10">
                <h2 class="text-2xl font-bold mb-6 text-center">🎉 ポスターが完成しました！ 🎉</h2>
                <div class="bg-amber-50 p-6 rounded-lg border border-amber-200">
                    <div id="poster-image-container" class="mb-4 flex justify-center relative">
                        <canvas id="poster-canvas" class="hidden max-w-full rounded-lg shadow-lg"></canvas>
                        <img id="poster-result-image" alt="生成されたポスター" class="max-w-full rounded-lg shadow-lg">
                    </div>
                    <div class="mb-4 p-4 bg-white rounded-lg border border-amber-200">
                        <p class="text-sm text-gray-700 mb-2 font-semibold">表示する文言（文字化け対策・任意）</p>
                        <p class="text-xs text-gray-500 mb-2">ここに入力した文言をポスターに重ねて表示・ダウンロードできます。AIが画像内に描いた文字が化けている場合にご利用ください。</p>
                        <div class="flex flex-wrap items-center gap-2">
                            <input type="text" id="poster-overlay-text" placeholder="例：期間限定！" class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500">
                            <button type="button" id="poster-apply-overlay-btn" class="px-4 py-2 bg-amber-100 text-amber-800 font-semibold rounded-lg hover:bg-amber-200 transition">反映して表示</button>
                            <button type="button" id="poster-clear-overlay-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">クリア</button>
                        </div>
                    </div>
                    <div class="text-center">
                        <button id="download-poster-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-amber-600 transition-all shadow-md inline-flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>
                            ポスターをダウンロード
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const dropZone = document.getElementById('drop-zone');
        const filePreviewContainer = document.getElementById('file-preview-container');
        const uploadPrompt = document.getElementById('upload-prompt');
        const clearFilesBtn = document.getElementById('clear-files-btn');
        const scenarioCheckboxes = document.getElementById('scenario-checkboxes');
        const appealCheckboxes = document.getElementById('appeal-checkboxes'); // Step 3 checkboxes
        const scenarioDetail = document.getElementById('scenario-detail');
        const speakerCount = document.getElementById('speaker-count');
        const generateBtn = document.getElementById('generate-btn');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const resultSection = document.getElementById('result-section');
        const resultImageContainer = document.getElementById('result-image-container');
        const resultImage = document.getElementById('result-image');
        const imageCounter = document.getElementById('image-counter');
        const scriptEditor = document.getElementById('script-editor');
        const playFullAdBtn = document.getElementById('play-full-ad-btn');
        const voiceSelectors = document.getElementById('voice-selectors');
        const modeSelector = document.getElementById('mode-selector');
        const fileInputSection = document.getElementById('file-input-section');
        const urlInputSection = document.getElementById('url-input-section');
        const urlInput = document.getElementById('url-input');
        const importCsvBtn = document.getElementById('import-csv-btn');
        const csvImportInput = document.getElementById('csv-import-input');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const downloadFullAudioBtn = document.getElementById('download-full-audio-btn');
        const translateLanguage = document.getElementById('translate-language');
        const translateBtn = document.getElementById('translate-btn');
        const bgmFileInput = document.getElementById('bgm-file-input');
        const bgmFileSelectBtn = document.getElementById('bgm-file-select-btn');
        const bgmFileName = document.getElementById('bgm-file-name');
        const bgmVolumeSlider = document.getElementById('bgm-volume-slider');
        const bgmVolumeValue = document.getElementById('bgm-volume-value');
        const downloadWithBgmBtn = document.getElementById('download-with-bgm-btn');
        const voiceFlow = document.getElementById('voice-flow');
        const posterFlow = document.getElementById('poster-flow');
        const resultSectionPoster = document.getElementById('result-section-poster');
        const posterResultImage = document.getElementById('poster-result-image');
        const posterCanvas = document.getElementById('poster-canvas');
        const posterOverlayText = document.getElementById('poster-overlay-text');
        const posterApplyOverlayBtn = document.getElementById('poster-apply-overlay-btn');
        const posterClearOverlayBtn = document.getElementById('poster-clear-overlay-btn');
        const generatePosterBtn = document.getElementById('generate-poster-btn');
        const downloadPosterBtn = document.getElementById('download-poster-btn');

        // App State
        let currentMode = 'file';
        let sourceFiles = [];
        let generatedDialogue = [];
        let japaneseVoices = [];
        let currentLineIndex = 0;
        let isPlaying = false;
        let characterVoices = {};
        let characterColors = {}; // For color-coding speakers
        let imageSlideshowInterval = null; // スライドショー用タイマーID（未宣言バグ修正）
        const colors = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6']; // blue, green, red, orange, purple

        // VOICEVOX 用
        let voicevoxSpeakers = []; // { id, displayName } の配列（スタイル単位）
        let characterVoicevoxIds = {}; // キャラ名 -> VOICEVOX スピーカーID（スタイルID）
        let currentVoicevoxAudio = null; // 再生中の Audio（停止用）
        let lineAdvanceScheduled = false; // 1行につき1回だけ次に進むためのフラグ（句読点で onend が複数回出る対策）
        let currentPosterDataUrl = null; // ポスター画像の Data URL（ダウンロード用）

        // 音声 / ポスター分岐
        document.querySelectorAll('input[name="output-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const isPoster = e.target.value === 'poster';
                voiceFlow.classList.toggle('hidden', isPoster);
                posterFlow.classList.toggle('hidden', !isPoster);
                resultSection.classList.add('hidden');
                resultSectionPoster.classList.add('hidden');
            });
        });

        // Speech Synthesis Setup
        const synth = window.speechSynthesis;
        const prepareVoices = () => {
            japaneseVoices = synth.getVoices().filter(voice => voice.lang.startsWith('ja'));
        };
        synth.onvoiceschanged = prepareVoices;
        prepareVoices();

        // Mode Selector Logic
        modeSelector.addEventListener('change', (e) => {
            currentMode = e.target.value;
            if (currentMode === 'file') {
                fileInputSection.classList.remove('hidden');
                urlInputSection.classList.add('hidden');
            } else {
                fileInputSection.classList.add('hidden');
                urlInputSection.classList.remove('hidden');
            }
        });

        // 音声エンジン切替（ブラウザ / VOICEVOX）
        document.querySelectorAll('input[name="voice-engine"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const isVoicevox = e.target.value === 'voicevox';
                document.getElementById('voicevox-url-row').classList.toggle('hidden', !isVoicevox);
                const statusEl = document.getElementById('voicevox-status');
                statusEl.classList.remove('hidden');
                if (isVoicevox) {
                    statusEl.textContent = 'VOICEVOX に接続しています...';
                    fetchVoicevoxSpeakers().then(ok => {
                        statusEl.textContent = ok ? `VOICEVOX 対応（${voicevoxSpeakers.length} 種類の声）` : 'VOICEVOX に接続できません。Engine を起動してください。';
                        statusEl.style.color = ok ? '#059669' : '#dc2626';
                        if (ok && voiceSelectors.innerHTML) setupVoiceSelectors();
                    }).catch(() => {
                        statusEl.textContent = 'VOICEVOX に接続できません。Engine を起動してください。';
                        statusEl.style.color = '#dc2626';
                    });
                } else {
                    statusEl.textContent = '';
                    if (voiceSelectors.innerHTML) setupVoiceSelectors();
                }
            });
        });
        document.getElementById('voicevox-engine-url').addEventListener('change', () => {
            if (document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox') {
                fetchVoicevoxSpeakers().then(ok => {
                    const statusEl = document.getElementById('voicevox-status');
                    statusEl.textContent = ok ? `VOICEVOX 対応（${voicevoxSpeakers.length} 種類の声）` : '接続できません';
                    statusEl.style.color = ok ? '#059669' : '#dc2626';
                    if (ok && voiceSelectors.innerHTML) setupVoiceSelectors();
                });
            }
        });

        async function fetchVoicevoxSpeakers() {
            const base = document.getElementById('voicevox-engine-url').value.trim().replace(/\/$/, '');
            try {
                const res = await fetch(`${base}/speakers`);
                if (!res.ok) return false;
                const data = await res.json();
                voicevoxSpeakers = [];
                data.forEach(sp => {
                    (sp.styles || []).forEach(style => {
                        voicevoxSpeakers.push({
                            id: style.id,
                            displayName: `${sp.name}（${style.name}）`
                        });
                    });
                });
                return voicevoxSpeakers.length > 0;
            } catch (e) {
                console.warn('VOICEVOX fetch failed', e);
                return false;
            }
        }

        async function voicevoxSynthesize(text, speakerId) {
            const base = document.getElementById('voicevox-engine-url').value.trim().replace(/\/$/, '');
            const queryRes = await fetch(`${base}/audio_query?text=${encodeURIComponent(text)}&speaker=${speakerId}`, { method: 'POST' });
            if (!queryRes.ok) throw new Error('VOICEVOX audio_query failed');
            const query = await queryRes.json();
            const synthRes = await fetch(`${base}/synthesis?speaker=${speakerId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(query)
            });
            if (!synthRes.ok) throw new Error('VOICEVOX synthesis failed');
            const wavBlob = await synthRes.blob();
            return URL.createObjectURL(wavBlob);
        }

        // File Upload Logic
        dropZone.addEventListener('click', () => fileUpload.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'bg-blue-50'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('border-blue-500', 'bg-blue-50'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
        });
        fileUpload.addEventListener('change', (e) => { if (e.target.files.length > 0) handleFiles(e.target.files); });
        
        async function handleFiles(files) {
            const newFiles = Array.from(files);
            
            for (const file of newFiles) {
                try {
                    const fileData = { name: file.name, type: file.type || '' };
                    if (file.type && file.type.startsWith('image/')) {
                        fileData.fileType = 'image';
                        fileData.base64 = await toBase64(file);
                    } else {
                        fileData.fileType = 'document';
                        fileData.text = await parseDocument(file);
                    }
                    sourceFiles.push(fileData);
                } catch (err) {
                    console.error('ファイル処理エラー:', file.name, err);
                    alert(`「${file.name}」の読み込みに失敗しました。${err.message || ''}`);
                }
            }
            updateFilePreviews();
        }

        function updateFilePreviews() {
            filePreviewContainer.innerHTML = '';
            if (sourceFiles.length > 0) {
                uploadPrompt.classList.add('hidden');
                clearFilesBtn.classList.remove('hidden');
            } else {
                uploadPrompt.classList.remove('hidden');
                clearFilesBtn.classList.add('hidden');
            }

            sourceFiles.forEach(file => {
                const preview = document.createElement('div');
                preview.className = 'thumbnail';
                if (file.fileType === 'image') {
                    const img = document.createElement('img');
                    img.src = file.base64;
                    img.className = 'w-full h-full object-cover rounded-md';
                    preview.appendChild(img);
                } else {
                    preview.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-gray-400 mb-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg><span>${file.name}</span>`;
                }
                filePreviewContainer.appendChild(preview);
            });
        }

        clearFilesBtn.addEventListener('click', () => {
            sourceFiles = [];
            updateFilePreviews();
            fileUpload.value = ''; 
        });

        const toBase64 = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });

        async function parseDocument(file) {
            const arrayBuffer = await file.arrayBuffer();
            if (file.type === 'application/pdf') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    text += content.items.map(item => item.str).join(' ');
                }
                return text;
            } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                return result.value;
            } else if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') {
                const workbook = XLSX.read(arrayBuffer, {type: 'buffer'});
                let text = '';
                workbook.SheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    text += XLSX.utils.sheet_to_csv(worksheet);
                });
                return text;
            }
            return 'サポートされていないファイル形式です。';
        }

        // Generation Logic
        generateBtn.addEventListener('click', async () => {
            const isFileMode = currentMode === 'file' && sourceFiles.length > 0;
            const isUrlMode = currentMode === 'url' && urlInput.value;

            if (!isFileMode && !isUrlMode) {
                alert('素材（ファイルまたはURL）を入力してください。');
                return;
            }
            
            // Warm up speech synthesis engine on user gesture
            synth.cancel(); // Clear any previous state
            synth.speak(new SpeechSynthesisUtterance(''));

            loading.classList.remove('hidden');
            loading.classList.add('flex');
            loadingText.textContent = isUrlMode ? 'URLの内容を読み取っています...' : 'AIが台本を生成中です...';
            resultSection.classList.add('hidden');
            generateBtn.disabled = true;
            try {
                const scriptText = await generateScript();
                const jsonMatch = scriptText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) throw new Error("AI response did not contain valid JSON.");
                const scriptData = JSON.parse(jsonMatch[0]);
                displayResults(scriptData);
            } catch (error) {
                console.error('Error:', error);
                const msg = error && error.message ? error.message : 'エラーが発生しました。AIが不完全な応答を返した可能性があります。もう一度お試しください。';
                alert(msg);
            } finally {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                generateBtn.disabled = false;
            }
        });

        // ポスター生成
        generatePosterBtn.addEventListener('click', async () => {
            if (!GEMINI_API_KEY || !GEMINI_API_KEY.trim()) {
                alert('Gemini APIキーが設定されていません。コード内の GEMINI_API_KEY を設定してください。');
                return;
            }
            let sourceSummary = '';
            if (currentMode === 'url') {
                if (!urlInput.value.trim()) {
                    alert('URLを入力してください。');
                    return;
                }
                try {
                    loading.classList.remove('hidden');
                    loading.classList.add('flex');
                    loadingText.textContent = 'URLの内容を読み取っています...';
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
                    const res = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: `次のURLのウェブページの内容を要約し、広告ポスターのテーマとして使える短い説明（日本語・2〜3文）で返してください。\nURL: ${urlInput.value.trim()}` }] }]
                        })
                    });
                    const data = await res.json();
                    if (data.candidates && data.candidates[0].content.parts[0].text) {
                        sourceSummary = data.candidates[0].content.parts[0].text.trim();
                    } else {
                        sourceSummary = 'このURLの内容を元にした広告';
                    }
                } catch (e) {
                    console.error(e);
                    sourceSummary = 'このURLの内容を元にした広告';
                }
            } else {
                if (sourceFiles.length === 0) {
                    alert('ファイルをアップロードするか、URLを入力してください。');
                    loading.classList.add('hidden');
                    loading.classList.remove('flex');
                    return;
                }
                const texts = sourceFiles.filter(f => f.text).map(f => f.text);
                sourceSummary = texts.length > 0 ? texts.join('\n').slice(0, 1500) : 'アップロードされた素材を元にした広告';
            }

            const toneEls = document.querySelectorAll('#poster-tone-checkboxes input[type="checkbox"]:checked');
            const toneText = toneEls.length ? Array.from(toneEls).map(cb => cb.value).join('、') : 'バランスの取れた';
            const emphasisEls = document.querySelectorAll('#poster-emphasis-checkboxes input[type="checkbox"]:checked');
            const emphasisText = emphasisEls.length ? Array.from(emphasisEls).map(cb => cb.value).join('、') : '';
            const aspectRatio = document.getElementById('poster-size').value;

            const imagePrompt = `Create a single, professional advertising poster image (Japanese-friendly design). 
Theme/source: ${sourceSummary}
Tone and manner: ${toneText}
${emphasisText ? `Emphasize: ${emphasisText}.` : ''}
IMPORTANT: Do NOT draw or render any text, letters, characters, or words in the image. No Japanese, no English, no numbers. Visual design only (illustration, colors, shapes, photos). Text will be added separately. Output only the image.`;

            const parts = [{ text: imagePrompt }];
            if (currentMode === 'file') {
                const imageFiles = sourceFiles.filter(f => f.fileType === 'image');
                for (const file of imageFiles.slice(0, 2)) {
                    parts.push({ inline_data: { mime_type: (file.base64 || '').match(/data:([^;]+)/)?.[1] || 'image/png', data: (file.base64 || '').split(',')[1] } });
                }
            }

            resultSectionPoster.classList.add('hidden');
            generatePosterBtn.disabled = true;
            loading.classList.remove('hidden');
            loading.classList.add('flex');
            loadingText.textContent = 'ポスターを生成中です... (数十秒かかることがあります)';
            try {
                const modelId = 'gemini-2.5-flash-image';
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${GEMINI_API_KEY}`;
                const payload = {
                    contents: [{ parts }],
                    generationConfig: {
                        responseModalities: ['TEXT', 'IMAGE'],
                        imageConfig: {
                            aspectRatio: aspectRatio,
                            imageSize: '2K'
                        }
                    }
                };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (!response.ok) {
                    const errMsg = result.error && result.error.message ? result.error.message : response.statusText;
                    throw new Error(`APIエラー: ${errMsg}`);
                }
                let imageData = null;
                if (result.candidates && result.candidates[0].content.parts) {
                    for (const part of result.candidates[0].content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            const mime = part.inlineData.mimeType || 'image/png';
                            imageData = `data:${mime};base64,${part.inlineData.data}`;
                            break;
                        }
                    }
                }
                if (!imageData) {
                    throw new Error('画像が返されませんでした。別のモデルやプロンプトでお試しください。');
                }
                currentPosterDataUrl = imageData;
                posterResultImage.src = imageData;
                posterOverlayText.value = '';
                posterCanvas.classList.add('hidden');
                posterResultImage.classList.remove('hidden');
                resultSectionPoster.classList.remove('hidden');
            } catch (error) {
                console.error(error);
                alert(error && error.message ? error.message : 'ポスターの生成に失敗しました。');
            } finally {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                generatePosterBtn.disabled = false;
            }
        });

        function drawPosterWithOverlay(imageDataUrl, text, canvasEl, onDone) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                canvasEl.width = img.naturalWidth;
                canvasEl.height = img.naturalHeight;
                const ctx = canvasEl.getContext('2d');
                ctx.drawImage(img, 0, 0);
                if (text && text.trim()) {
                    const fontSize = Math.max(32, Math.min(canvasEl.width, canvasEl.height) / 10);
                    ctx.font = `bold ${fontSize}px "Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const x = canvasEl.width / 2;
                    const y = canvasEl.height * 0.85;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = fontSize / 8;
                    ctx.strokeText(text.trim(), x, y);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(text.trim(), x, y);
                }
                if (onDone) onDone();
            };
            img.onerror = () => { if (onDone) onDone(); };
            img.src = imageDataUrl;
        }

        posterApplyOverlayBtn.addEventListener('click', () => {
            const text = posterOverlayText.value.trim();
            if (!currentPosterDataUrl) return;
            if (!text) {
                posterCanvas.classList.add('hidden');
                posterResultImage.classList.remove('hidden');
                posterResultImage.src = currentPosterDataUrl;
                return;
            }
            drawPosterWithOverlay(currentPosterDataUrl, text, posterCanvas, () => {
                posterCanvas.classList.remove('hidden');
                posterResultImage.classList.add('hidden');
            });
        });

        posterClearOverlayBtn.addEventListener('click', () => {
            posterOverlayText.value = '';
            posterCanvas.classList.add('hidden');
            posterResultImage.classList.remove('hidden');
            posterResultImage.src = currentPosterDataUrl || '';
        });

        downloadPosterBtn.addEventListener('click', () => {
            if (!currentPosterDataUrl) return;
            const text = posterOverlayText.value.trim();
            let dataUrl = currentPosterDataUrl;
            if (text && posterCanvas.classList.contains('hidden')) {
                const img = new Image();
                img.onload = () => {
                    posterCanvas.width = img.naturalWidth;
                    posterCanvas.height = img.naturalHeight;
                    const ctx = posterCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const fontSize = Math.max(32, Math.min(posterCanvas.width, posterCanvas.height) / 10);
                    ctx.font = `bold ${fontSize}px "Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const x = posterCanvas.width / 2;
                    const y = posterCanvas.height * 0.85;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = fontSize / 8;
                    ctx.strokeText(text, x, y);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(text, x, y);
                    const out = posterCanvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = out;
                    a.download = `poster_${Date.now()}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
                img.src = currentPosterDataUrl;
                return;
            }
            if (text && !posterCanvas.classList.contains('hidden')) {
                dataUrl = posterCanvas.toDataURL('image/png');
            }
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = `poster_${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Gemini API Call
        const GEMINI_API_KEY = "AIzaSyDtf6N3IOF874fByFP77tcA1CG6WogEbDc"; // Gemini APIキー

        async function callGemini(parts) {
            if (!GEMINI_API_KEY || !GEMINI_API_KEY.trim()) {
                throw new Error("Gemini APIキーが設定されていません。コード内の GEMINI_API_KEY を設定してください。");
            }
            const payload = {
                contents: [{ parts: parts }],
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const result = await response.json();
            if (!response.ok) {
                const errMsg = result.error && result.error.message ? result.error.message : response.statusText;
                throw new Error(`APIエラー: ${errMsg}`);
            }
            if (result.candidates && result.candidates.length > 0) {
                const part = result.candidates[0].content.parts[0];
                if (!part || !part.text) throw new Error("API応答にテキストが含まれていません。");
                return part.text;
            }
            if (result.promptFeedback && result.promptFeedback.blockReason) {
                throw new Error(`コンテンツがブロックされました: ${result.promptFeedback.blockReason}`);
            }
            throw new Error("API response was empty.");
        }

        async function generateScript() {
            const numSpeakers = Math.max(1, Math.min(10, parseInt(speakerCount.value, 10) || 2));
            
            // Collect Step 2: Atmosphere/Format
            const checkedScenarioCheckboxes = document.querySelectorAll('#scenario-checkboxes input[type="checkbox"]:checked');
            let scenarioPromptText = "【雰囲気・形式】: " + Array.from(checkedScenarioCheckboxes).map(cb => cb.value).join('、');
            
            // Collect Step 3: Specific Appeals
            const checkedAppealCheckboxes = document.querySelectorAll('#appeal-checkboxes input[type="checkbox"]:checked');
            const appealText = Array.from(checkedAppealCheckboxes).map(cb => cb.value).join('、');
            if (appealText) {
                scenarioPromptText += `\n【具体的な訴求ポイント】: ${appealText}`;
            }

            // Collect Free Text Details
            const detailText = scenarioDetail.value.trim();
            if (detailText) {
                scenarioPromptText += `\n【その他の自由記述指示】: ${detailText}`;
            }

            let prompt;
            const parts = [];

            const commonRules = `
# ルール
- 登場人物は${String(numSpeakers)}人にしてください。
- 指定された【雰囲気・形式】と【訴求ポイント】を厳密に守ってください。
- 特に「新商品アピール」や「価格強調」などの指示がある場合は、セリフの中で明確に言及してください。
- 出力は必ず以下のJSON形式に従ってください。

{"dialogue": [{"character": "登場人物1の名前", "line": "セリフ1"}, {"character": "登場人物2の名前", "line": "セリフ2"}]}
            `;

            if (currentMode === 'url') {
                prompt = `指定されたURLのウェブページの内容を読み取り、その内容を要約してください。その後、その要約と以下のシナリオ指示に基づいて、登場人物${String(numSpeakers)}人による魅力的な会話形式の台本を作成してください。\n\n# URL\n${urlInput.value}\n\n# シナリオの指示\n${scenarioPromptText}\n${commonRules}`;
                parts.push({ text: prompt });
            } else { // file mode
                prompt = `以下の【すべてのファイル】の内容を注意深く分析し、それら全ての情報を網羅した、一貫性のある会話台本を1つだけ作成してください。\n\n# シナリオの指示\n${scenarioPromptText}\n${commonRules}`;
                parts.push({ text: prompt });
                sourceFiles.forEach(file => {
                    if (file.fileType === 'image') {
                        parts.push({ inline_data: { mime_type: file.type, data: file.base64.split(',')[1] } });
                    } else {
                        parts.push({ text: `\n--- ファイル「${file.name}」の内容 ---\n${file.text}\n--- 内容ここまで ---` });
                    }
                });
            }
            
            const payload = {
                contents: [{ parts: parts }],
                generation_config: { "response_mime_type": "application/json" }
            };
            if (!GEMINI_API_KEY || !GEMINI_API_KEY.trim()) {
                throw new Error("Gemini APIキーが設定されていません。コード内の GEMINI_API_KEY を設定してください。");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const result = await response.json();
            if (!response.ok) {
                const errMsg = result.error && result.error.message ? result.error.message : response.statusText;
                throw new Error(`APIエラー: ${errMsg}`);
            }
            if (result.candidates && result.candidates.length > 0) {
                const part = result.candidates[0].content.parts[0];
                if (!part || !part.text) throw new Error("API応答にテキストが含まれていません。");
                return part.text;
            }
            if (result.promptFeedback && result.promptFeedback.blockReason) {
                throw new Error(`コンテンツがブロックされました: ${result.promptFeedback.blockReason}`);
            }
            throw new Error("API response was empty.");
        }

        // UI Display Logic
        function displayResults(data) {
            if (!data || !Array.isArray(data.dialogue) || data.dialogue.length === 0) {
                console.error('displayResults: 無効な dialogue データ', data);
                alert('台本データが正しく取得できませんでした。');
                return;
            }
            generatedDialogue = data.dialogue;
            
            const imageSources = sourceFiles.filter(f => f.fileType === 'image');
            if (currentMode === 'file' && imageSources.length > 0) {
                resultImageContainer.classList.remove('hidden');
                resultImage.src = imageSources[0].base64;
                imageCounter.textContent = `画像 1 / ${imageSources.length}`;
            } else {
                resultImageContainer.classList.add('hidden');
                imageCounter.textContent = '';
            }
            
            setupVoiceSelectors();
            setupScriptEditor();
            resultSection.classList.remove('hidden');
        }

        function setupVoiceSelectors() {
            voiceSelectors.innerHTML = '';
            characterVoices = {};
            characterVoicevoxIds = {};
            characterColors = {};
            const characters = [...new Set(generatedDialogue.map(item => item.character).filter(c => c != null && String(c).trim() !== ''))];
            const useVoicevox = document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox';

            if (useVoicevox) {
                if (voicevoxSpeakers.length === 0) {
                    voiceSelectors.innerHTML = '<p class="text-amber-600">VOICEVOX を選択しましたが、Engine に接続できていません。上で「VOICEVOX」を選び直すか、VOICEVOX Engine を起動してください。</p>';
                    return;
                }
                characters.forEach((char, index) => {
                    characterColors[char] = colors[index % colors.length];
                    const selectorDiv = document.createElement('div');
                    selectorDiv.className = 'flex items-center justify-between gap-4';
                    const label = document.createElement('label');
                    label.textContent = `${char}の声:`;
                    label.className = 'font-semibold flex-shrink-0';
                    label.style.color = characterColors[char];
                    const select = document.createElement('select');
                    select.className = 'w-full p-2 border rounded-md bg-white';
                    voicevoxSpeakers.forEach((s, i) => {
                        const option = document.createElement('option');
                        option.value = s.id;
                        option.textContent = s.displayName;
                        select.appendChild(option);
                    });
                    const initialId = voicevoxSpeakers[Math.min(index % voicevoxSpeakers.length, voicevoxSpeakers.length - 1)].id;
                    select.value = String(initialId);
                    characterVoicevoxIds[char] = initialId;
                    select.onchange = () => { characterVoicevoxIds[char] = parseInt(select.value, 10); };
                    selectorDiv.appendChild(label);
                    selectorDiv.appendChild(select);
                    voiceSelectors.appendChild(selectorDiv);
                });
                return;
            }

            if (japaneseVoices.length === 0) {
                voiceSelectors.innerHTML = '<p class="text-red-500">利用可能な音声が読み込めませんでした。ブラウザをリロードしてみてください。</p>';
                return;
            }

            characters.forEach((char, index) => {
                characterColors[char] = colors[index % colors.length];

                const selectorDiv = document.createElement('div');
                selectorDiv.className = 'flex items-center justify-between gap-4';
                
                const label = document.createElement('label');
                label.textContent = `${char}の声:`;
                label.className = 'font-semibold flex-shrink-0';
                label.style.color = characterColors[char];

                const select = document.createElement('select');
                select.className = 'w-full p-2 border rounded-md bg-white';
                
                japaneseVoices.forEach((voice, vIndex) => {
                    const option = document.createElement('option');
                    option.value = vIndex;
                    option.textContent = voice.name;
                    select.appendChild(option);
                });

                const initialIndex = index % japaneseVoices.length;
                select.value = String(initialIndex);
                characterVoices[char] = japaneseVoices[initialIndex];

                select.onchange = () => {
                    const idx = parseInt(select.value, 10);
                    characterVoices[char] = japaneseVoices[idx];
                };
                
                selectorDiv.appendChild(label);
                selectorDiv.appendChild(select);
                voiceSelectors.appendChild(selectorDiv);
            });
        }

        function insertRowAfter(index) {
            const d = parseScriptFromEditor();
            d.splice(index + 1, 0, { character: '', line: '' });
            generatedDialogue = d;
            setupScriptEditor();
        }

        function appendRow() {
            const d = parseScriptFromEditor();
            d.push({ character: '', line: '' });
            generatedDialogue = d;
            setupScriptEditor();
        }

        function deleteRow(index) {
            const d = parseScriptFromEditor();
            if (d.length <= 1) {
                alert('最後の1行は削除できません。');
                return;
            }
            d.splice(index, 1);
            generatedDialogue = d;
            setupScriptEditor();
        }

        function setupScriptEditor() {
            scriptEditor.innerHTML = '';
            generatedDialogue.forEach((item, index) => {
                const color = characterColors[item.character] || '#374151';

                const lineDiv = document.createElement('div');
                lineDiv.className = 'flex items-center gap-2 flex-wrap';

                const charInput = document.createElement('input');
                charInput.type = 'text';
                charInput.value = item.character;
                charInput.className = 'p-1 border-none rounded-md w-28 font-semibold text-white text-center';
                charInput.style.backgroundColor = color;
                charInput.setAttribute('data-index', index);
                charInput.setAttribute('data-type', 'character');
                charInput.placeholder = 'キャラ名';

                const lineInput = document.createElement('input');
                lineInput.type = 'text';
                lineInput.value = item.line;
                lineInput.className = 'p-1 border rounded-md flex-grow min-w-[120px]';
                lineInput.style.borderLeft = `4px solid ${color}`;
                lineInput.setAttribute('data-index', index);
                lineInput.setAttribute('data-type', 'line');
                lineInput.placeholder = 'セリフ';

                const copyButton = document.createElement('button');
                copyButton.title = 'テキストをコピー';
                copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" /><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" /></svg>`;
                copyButton.className = 'bg-gray-200 hover:bg-gray-300 p-2 rounded-md transition';
                copyButton.onclick = () => {
                    const textToCopy = lineInput.value;
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    copyButton.classList.add('text-green-500');
                    setTimeout(() => copyButton.classList.remove('text-green-500'), 1500);
                };

                const downloadBtn = document.createElement('button');
                downloadBtn.title = 'この行の音声をダウンロード（VOICEVOX選択時）';
                downloadBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>`;
                downloadBtn.className = 'bg-emerald-100 hover:bg-emerald-200 p-2 rounded-md transition text-emerald-800';
                downloadBtn.onclick = async () => {
                    const useVoicevox = document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox';
                    if (!useVoicevox || voicevoxSpeakers.length === 0) {
                        alert('音声のダウンロードは「VOICEVOX（ずんだもん等）」を選択した状態で利用できます。');
                        return;
                    }
                    const char = charInput.value.trim() || '話者';
                    const text = lineInput.value.trim();
                    if (!text) {
                        alert('セリフが空です。');
                        return;
                    }
                    const speakerId = characterVoicevoxIds[char] ?? voicevoxSpeakers[0].id;
                    downloadBtn.disabled = true;
                    downloadBtn.classList.add('opacity-50');
                    try {
                        const base = document.getElementById('voicevox-engine-url').value.trim().replace(/\/$/, '');
                        const queryRes = await fetch(`${base}/audio_query?text=${encodeURIComponent(text)}&speaker=${speakerId}`, { method: 'POST' });
                        if (!queryRes.ok) throw new Error('VOICEVOX に接続できません');
                        const query = await queryRes.json();
                        const synthRes = await fetch(`${base}/synthesis?speaker=${speakerId}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(query) });
                        if (!synthRes.ok) throw new Error('音声の生成に失敗しました');
                        const blob = await synthRes.blob();
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `voice_${String(index + 1).padStart(3, '0')}_${char.replace(/[/\\?*:|"]/g, '_')}.wav`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error(e);
                        alert('ダウンロードに失敗しました。VOICEVOX Engine が起動しているか確認してください。');
                    } finally {
                        downloadBtn.disabled = false;
                        downloadBtn.classList.remove('opacity-50');
                    }
                };

                const insertDialogueBtn = document.createElement('button');
                insertDialogueBtn.type = 'button';
                insertDialogueBtn.textContent = '下にセリフ';
                insertDialogueBtn.title = 'この行の直下にセリフ行を挿入';
                insertDialogueBtn.className = 'text-xs px-2 py-1 bg-blue-100 hover:bg-blue-200 rounded text-blue-800';
                insertDialogueBtn.onclick = () => insertRowAfter(index);

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.textContent = '削除';
                deleteBtn.title = 'この行を削除';
                deleteBtn.className = 'text-xs px-2 py-1 bg-red-100 hover:bg-red-200 rounded text-red-800';
                deleteBtn.onclick = () => deleteRow(index);

                lineDiv.appendChild(charInput);
                lineDiv.appendChild(lineInput);
                lineDiv.appendChild(copyButton);
                lineDiv.appendChild(downloadBtn);
                lineDiv.appendChild(insertDialogueBtn);
                lineDiv.appendChild(deleteBtn);
                scriptEditor.appendChild(lineDiv);
            });

            const endRow = document.createElement('div');
            endRow.className = 'flex items-center gap-2 mt-2 pt-2 border-t border-gray-200';
            const addDialogueBtn = document.createElement('button');
            addDialogueBtn.type = 'button';
            addDialogueBtn.textContent = '行を追加';
            addDialogueBtn.title = '新しいセリフ行を末尾に追加（キャラ名・セリフを入力するとそのメンバーが読み上げます）';
            addDialogueBtn.className = 'px-3 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md text-sm font-medium';
            addDialogueBtn.onclick = () => appendRow();
            endRow.appendChild(addDialogueBtn);
            scriptEditor.appendChild(endRow);
        }

        // Playback Logic
        playFullAdBtn.addEventListener('click', () => {
            if (isPlaying) {
                stopFullAd();
            } else {
                const activeElement = document.activeElement;
                let startingIndex = 0;
                if (activeElement && activeElement.parentElement.parentElement === scriptEditor && activeElement.hasAttribute('data-index')) {
                    startingIndex = parseInt(activeElement.getAttribute('data-index'), 10);
                }
                startFullAd(startingIndex);
            }
        });

        function parseScriptFromEditor() {
            const newDialogue = [];
            const lineDivs = scriptEditor.querySelectorAll('div');
            lineDivs.forEach(div => {
                const charInput = div.querySelector('input[data-type="character"]');
                const lineInput = div.querySelector('input[data-type="line"]');
                if (charInput && lineInput) {
                    newDialogue.push({
                        character: charInput.value,
                        line: lineInput.value
                    });
                }
            });
            return newDialogue;
        }
        
        async function startFullAd(startingIndex = 0) {
            generatedDialogue = parseScriptFromEditor();
            if (generatedDialogue.length === 0) return;
            
            isPlaying = true;
            playFullAdBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 00-1 1v2a1 1 0 001 1h6a1 1 0 001-1V9a1 1 0 00-1-1H7z" clip-rule="evenodd" /></svg>停止する`;
            
            const imageSources = sourceFiles.filter(f => f.fileType === 'image');
            let imageIndex = 0;
            if (imageSlideshowInterval) clearInterval(imageSlideshowInterval);
            imageSlideshowInterval = null;
            if (currentMode === 'file' && imageSources.length > 1) {
                imageSlideshowInterval = setInterval(() => {
                    imageIndex = (imageIndex + 1) % imageSources.length;
                    resultImage.style.opacity = 0;
                    setTimeout(() => {
                        resultImage.src = imageSources[imageIndex].base64;
                        resultImage.style.opacity = 1;
                        imageCounter.textContent = `画像 ${imageIndex + 1} / ${imageSources.length}`;
                    }, 500);
                }, 3000);
            }

            currentLineIndex = startingIndex;
            speakFullAd();
        }

        function stopFullAd() {
            isPlaying = false;
            synth.cancel();
            if (currentVoicevoxAudio) {
                currentVoicevoxAudio.onended = null;
                currentVoicevoxAudio.onerror = null;
                currentVoicevoxAudio.pause();
                currentVoicevoxAudio.src = '';
                currentVoicevoxAudio = null;
            }
            if (imageSlideshowInterval) {
                clearInterval(imageSlideshowInterval);
                imageSlideshowInterval = null;
            }
            playFullAdBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>ここから再生`;
            const imageSources = sourceFiles.filter(f => f.fileType === 'image');
            if (currentMode === 'file' && imageSources.length > 0) {
                resultImage.src = imageSources[0].base64;
                resultImage.style.opacity = 1;
                imageCounter.textContent = `画像 1 / ${imageSources.length}`;
            }
        }

        // ブラウザの音声が「喋り終わった」と判定されるまで待つ（onend が早く出る場合の対策）
        function waitUntilSpeechEnd() {
            return new Promise(resolve => {
                const check = () => {
                    if (!isPlaying) { resolve(); return; }
                    if (!synth.speaking) {
                        setTimeout(() => resolve(), 200);
                        return;
                    }
                    setTimeout(check, 100);
                };
                check();
            });
        }

        async function speakFullAd() {
            if (currentLineIndex >= generatedDialogue.length || !isPlaying) {
                stopFullAd();
                return;
            }
            lineAdvanceScheduled = false;

            const item = generatedDialogue[currentLineIndex];
            if (!item.line || !String(item.line).trim()) {
                currentLineIndex++;
                setTimeout(speakFullAd, 0);
                return;
            }
            const useVoicevox = document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox';

            if (useVoicevox && voicevoxSpeakers.length > 0) {
                const speakerId = characterVoicevoxIds[item.character] ?? voicevoxSpeakers[0].id;
                try {
                    const blobUrl = await voicevoxSynthesize(item.line, speakerId);
                    if (!isPlaying) return;
                    if (currentVoicevoxAudio) {
                        currentVoicevoxAudio.onended = null;
                        currentVoicevoxAudio.onerror = null;
                        currentVoicevoxAudio.pause();
                        currentVoicevoxAudio.src = '';
                        currentVoicevoxAudio = null;
                    }
                    currentVoicevoxAudio = new Audio(blobUrl);
                    currentVoicevoxAudio.onended = () => {
                        if (lineAdvanceScheduled) return;
                        lineAdvanceScheduled = true;
                        URL.revokeObjectURL(blobUrl);
                        currentLineIndex++;
                        setTimeout(speakFullAd, 350);
                    };
                    currentVoicevoxAudio.onerror = (e) => {
                        if (lineAdvanceScheduled) return;
                        lineAdvanceScheduled = true;
                        console.error('VOICEVOX playback error', e);
                        URL.revokeObjectURL(blobUrl);
                        currentLineIndex++;
                        setTimeout(speakFullAd, 350);
                    };
                    currentVoicevoxAudio.play();
                } catch (e) {
                    console.error('VOICEVOX synthesize error', e);
                    currentLineIndex++;
                    setTimeout(speakFullAd, 500);
                }
                return;
            }

            synth.cancel();
            const utterance = new SpeechSynthesisUtterance(item.line);
            if (characterVoices[item.character]) {
                utterance.voice = characterVoices[item.character];
            } else {
                const firstVoice = japaneseVoices[0];
                if (firstVoice) utterance.voice = firstVoice;
            }
            utterance.onend = () => {
                if (lineAdvanceScheduled) return;
                lineAdvanceScheduled = true;
                waitUntilSpeechEnd().then(() => {
                    currentLineIndex++;
                    speakFullAd();
                });
            };
            utterance.onerror = (e) => {
                if (lineAdvanceScheduled) return;
                lineAdvanceScheduled = true;
                console.error('SpeechSynthesisUtterance.onerror', e);
                waitUntilSpeechEnd().then(() => {
                    currentLineIndex++;
                    speakFullAd();
                });
            };
            synth.speak(utterance);
        }

        // CSV Import/Export Logic
        importCsvBtn.addEventListener('click', () => {
            csvImportInput.click();
        });

        csvImportInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const dialogue = parseCSV(text);
                if (!dialogue || dialogue.length === 0) {
                    alert('CSVに有効な台本が含まれていません。1行目は見出し（character,line）、2行目以降に「キャラ名,セリフ」を記載してください。');
                    event.target.value = '';
                    return;
                }
                clearFilesBtn.click();
                urlInput.value = '';
                scenarioDetail.value = 'CSVからインポートしました';
                displayResults({ dialogue });
                resultSection.scrollIntoView({ behavior: 'smooth' });
            };
            reader.readAsText(file);
        });

        exportCsvBtn.addEventListener('click', () => {
            const dialogue = parseScriptFromEditor();
            if (dialogue.length === 0) {
                alert('エクスポートする台本がありません。');
                return;
            }
            const csvContent = generateCSV(dialogue);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'script.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        downloadFullAudioBtn.addEventListener('click', async () => {
            const dialogue = parseScriptFromEditor();
            if (dialogue.length === 0) {
                alert('台本がありません。');
                return;
            }
            const useVoicevox = document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox';
            if (!useVoicevox || voicevoxSpeakers.length === 0) {
                alert('「音声をまとめてダウンロード」は VOICEVOX 選択時のみ利用できます。');
                return;
            }
            const base = document.getElementById('voicevox-engine-url').value.trim().replace(/\/$/, '');
            const GAP_SEC = 0.2;
            downloadFullAudioBtn.disabled = true;
            downloadFullAudioBtn.textContent = '生成中...';
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const buffers = [];
                let sampleRate = 24000;
                let numChannels = 1;
                for (let i = 0; i < dialogue.length; i++) {
                    const d = dialogue[i];
                    const speakerId = characterVoicevoxIds[d.character] ?? voicevoxSpeakers[0].id;
                    const text = d.line.trim();
                    if (!text) continue;
                    const queryRes = await fetch(`${base}/audio_query?text=${encodeURIComponent(text)}&speaker=${speakerId}`, { method: 'POST' });
                    if (!queryRes.ok) throw new Error(`行 ${i + 1} の取得に失敗`);
                    const query = await queryRes.json();
                    const synthRes = await fetch(`${base}/synthesis?speaker=${speakerId}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(query) });
                    if (!synthRes.ok) throw new Error(`行 ${i + 1} の音声生成に失敗`);
                    const blob = await synthRes.blob();
                    const buf = await ctx.decodeAudioData(await blob.arrayBuffer());
                    sampleRate = buf.sampleRate;
                    numChannels = buf.numberOfChannels;
                    buffers.push(buf);
                }
                if (buffers.length === 0) throw new Error('有効なセリフがありません');
                sampleRate = buffers[0].sampleRate;
                numChannels = buffers[0].numberOfChannels;
                const totalSamples = buffers.reduce((acc, b) => acc + b.length, 0) + Math.round(GAP_SEC * sampleRate) * (buffers.length - 1);
                const offline = new OfflineAudioContext(numChannels, totalSamples, sampleRate);
                let offset = 0;
                for (let i = 0; i < buffers.length; i++) {
                    const src = offline.createBufferSource();
                    src.buffer = buffers[i];
                    src.connect(offline.destination);
                    src.start(offset);
                    offset += buffers[i].length / sampleRate + GAP_SEC;
                }
                const rendered = await offline.startRendering();
                const wav = audioBufferToWav(rendered);
                const url = URL.createObjectURL(new Blob([wav], { type: 'audio/wav' }));
                const a = document.createElement('a');
                a.href = url;
                a.download = 'script_full_audio.wav';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error(e);
                alert('まとめてダウンロードに失敗しました。' + (e.message || ''));
            } finally {
                downloadFullAudioBtn.disabled = false;
                downloadFullAudioBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>音声をまとめてダウンロード`;
            }
        });

        bgmFileSelectBtn.addEventListener('click', () => bgmFileInput.click());
        bgmFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            bgmFileName.textContent = file ? file.name : '未選択';
        });
        bgmVolumeSlider.addEventListener('input', () => {
            bgmVolumeValue.textContent = bgmVolumeSlider.value;
        });

        downloadWithBgmBtn.addEventListener('click', async () => {
            const dialogue = parseScriptFromEditor();
            if (dialogue.length === 0) {
                alert('台本がありません。');
                return;
            }
            const useVoicevox = document.querySelector('input[name="voice-engine"]:checked').value === 'voicevox';
            if (!useVoicevox || voicevoxSpeakers.length === 0) {
                alert('「BGMを付けてダウンロード」は VOICEVOX 選択時のみ利用できます。');
                return;
            }
            if (!bgmFileInput.files || !bgmFileInput.files[0]) {
                alert('BGMファイルを選択してください。');
                return;
            }
            const base = document.getElementById('voicevox-engine-url').value.trim().replace(/\/$/, '');
            const GAP_SEC = 0.2;
            const bgmGain = parseInt(bgmVolumeSlider.value, 10) / 100;
            downloadWithBgmBtn.disabled = true;
            downloadWithBgmBtn.textContent = '生成中...';
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const buffers = [];
                let sampleRate = 24000;
                let numChannels = 1;
                for (let i = 0; i < dialogue.length; i++) {
                    const d = dialogue[i];
                    const speakerId = characterVoicevoxIds[d.character] ?? voicevoxSpeakers[0].id;
                    const text = d.line.trim();
                    if (!text) continue;
                    const queryRes = await fetch(`${base}/audio_query?text=${encodeURIComponent(text)}&speaker=${speakerId}`, { method: 'POST' });
                    if (!queryRes.ok) throw new Error(`行 ${i + 1} の取得に失敗`);
                    const query = await queryRes.json();
                    const synthRes = await fetch(`${base}/synthesis?speaker=${speakerId}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(query) });
                    if (!synthRes.ok) throw new Error(`行 ${i + 1} の音声生成に失敗`);
                    const blob = await synthRes.blob();
                    const buf = await ctx.decodeAudioData(await blob.arrayBuffer());
                    sampleRate = buf.sampleRate;
                    numChannels = buf.numberOfChannels;
                    buffers.push(buf);
                }
                if (buffers.length === 0) throw new Error('有効なセリフがありません');
                sampleRate = buffers[0].sampleRate;
                numChannels = buffers[0].numberOfChannels;
                const totalSamples = buffers.reduce((acc, b) => acc + b.length, 0) + Math.round(GAP_SEC * sampleRate) * (buffers.length - 1);
                const offlineVoice = new OfflineAudioContext(numChannels, totalSamples, sampleRate);
                let offset = 0;
                for (let i = 0; i < buffers.length; i++) {
                    const src = offlineVoice.createBufferSource();
                    src.buffer = buffers[i];
                    src.connect(offlineVoice.destination);
                    src.start(offset);
                    offset += buffers[i].length / sampleRate + GAP_SEC;
                }
                const voiceBuffer = await offlineVoice.startRendering();

                const bgmArrayBuffer = await bgmFileInput.files[0].arrayBuffer();
                const bgmBuffer = await ctx.decodeAudioData(bgmArrayBuffer);

                const outChannels = Math.max(voiceBuffer.numberOfChannels, bgmBuffer.numberOfChannels);
                const outLength = voiceBuffer.length;
                const outSampleRate = voiceBuffer.sampleRate;
                const offlineMix = new OfflineAudioContext(outChannels, outLength, outSampleRate);

                const voiceSrc = offlineMix.createBufferSource();
                voiceSrc.buffer = voiceBuffer;
                voiceSrc.connect(offlineMix.destination);
                voiceSrc.start(0);

                const voiceDurationSec = voiceBuffer.length / outSampleRate;
                const fadeOutSec = Math.min(2, voiceDurationSec * 0.5);

                const bgmSrc = offlineMix.createBufferSource();
                bgmSrc.buffer = bgmBuffer;
                bgmSrc.loop = true;
                const bgmGainNode = offlineMix.createGain();
                bgmGainNode.gain.setValueAtTime(bgmGain, 0);
                bgmGainNode.gain.linearRampToValueAtTime(bgmGain, Math.max(0, voiceDurationSec - fadeOutSec));
                bgmGainNode.gain.linearRampToValueAtTime(0, voiceDurationSec);
                bgmSrc.connect(bgmGainNode);
                bgmGainNode.connect(offlineMix.destination);
                bgmSrc.start(0);

                const mixed = await offlineMix.startRendering();
                const wav = audioBufferToWav(mixed);
                const url = URL.createObjectURL(new Blob([wav], { type: 'audio/wav' }));
                const a = document.createElement('a');
                a.href = url;
                a.download = 'script_full_audio_with_bgm.wav';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error(e);
                alert('BGM付きダウンロードに失敗しました。' + (e.message || ''));
            } finally {
                downloadWithBgmBtn.disabled = false;
                downloadWithBgmBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" clip-rule="evenodd" /></svg>BGMを付けてダウンロード`;
            }
        });

        function audioBufferToWav(buffer) {
            const numCh = buffer.numberOfChannels;
            const sr = buffer.sampleRate;
            const length = buffer.length * numCh * 2;
            const arrayBuffer = new ArrayBuffer(44 + length);
            const view = new DataView(arrayBuffer);
            const writeStr = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
            writeStr(0, 'RIFF');
            view.setUint32(4, 36 + length, true);
            writeStr(8, 'WAVE');
            writeStr(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numCh, true);
            view.setUint32(24, sr, true);
            view.setUint32(28, sr * numCh * 2, true);
            view.setUint16(32, numCh * 2, true);
            view.setUint16(34, 16, true);
            writeStr(36, 'data');
            view.setUint32(40, length, true);
            let pos = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numCh; ch++) {
                    const v = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
                    view.setInt16(pos, v < 0 ? v * 0x8000 : v * 0x7FFF, true);
                    pos += 2;
                }
            }
            return arrayBuffer;
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(l => l.trim());
            const dialogue = [];
            // Skip header
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const firstCommaIndex = line.indexOf(',');
                if (firstCommaIndex === -1) continue;
                
                const character = line.substring(0, firstCommaIndex).trim().replace(/"/g, '');
                let lineText = line.substring(firstCommaIndex + 1).trim();
                
                if (lineText.startsWith('"') && lineText.endsWith('"')) {
                    lineText = lineText.substring(1, lineText.length - 1).replace(/""/g, '"');
                }
                dialogue.push({ character, line: lineText });
            }
            return dialogue;
        }

        function generateCSV(dialogue) {
            let csvRows = ['"character","line"'];
            dialogue.forEach(item => {
                const character = `"${item.character.replace(/"/g, '""')}"`;
                const line = `"${item.line.replace(/"/g, '""')}"`;
                csvRows.push([character, line].join(','));
            });
            return csvRows.join('\n');
        }

        // Translate Logic
        translateBtn.addEventListener('click', async () => {
            const dialogue = parseScriptFromEditor();
            if (dialogue.length === 0) {
                alert('翻訳する台本がありません。');
                return;
            }
            const targetLanguage = translateLanguage.value;
            const originalText = dialogue.map(d => `${d.character}: ${d.line}`).join('\n');
            
            loading.classList.remove('hidden');
            loading.classList.add('flex');
            loadingText.textContent = `${targetLanguage}に翻訳中です...`;
            translateBtn.disabled = true;

            try {
                const characters = [...new Set(dialogue.map(item => item.character))].join(', ');
                const prompt = `以下の台本を【${targetLanguage}】に翻訳してください。登場人物の名前（${characters}）は変更せず、フォーマット「登場人物: セリフ」を維持してください。\n\n${originalText}`;
                const translatedText = await callGemini([{ text: prompt }]);
                
                const translatedDialogue = translatedText.split('\n').filter(line => line.trim() !== '').map(line => {
                    const colonIndex = line.indexOf(':');
                    if (colonIndex === -1) return { character: '?', line: line.trim() };
                    return {
                        character: line.substring(0, colonIndex).trim(),
                        line: line.substring(colonIndex + 1).trim()
                    };
                });

                if (translatedDialogue.length === 0) {
                    throw new Error('翻訳結果を解析できませんでした。');
                }
                displayResults({ dialogue: translatedDialogue });

            } catch (error) {
                console.error('Translation failed:', error);
                alert('翻訳に失敗しました。');
            } finally {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                translateBtn.disabled = false;
            }
        });

        document.getElementById('spec-toggle-btn').addEventListener('click', () => {
            const content = document.getElementById('spec-content');
            const icon = document.getElementById('spec-toggle-icon');
            content.classList.toggle('hidden');
            icon.textContent = content.classList.contains('hidden') ? '▼' : '▲';
        });

        // PWA: 常に最新版で開く（Service Worker 登録・更新時リロード）
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js', { updateViaCache: 'none' })
                .then((reg) => {
                    reg.onupdatefound = () => {
                        const newWorker = reg.installing;
                        newWorker.onstatechange = () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                newWorker.postMessage({ type: 'SKIP_WAITING' });
                            }
                        };
                    };
                    if (reg.waiting) reg.waiting.postMessage({ type: 'SKIP_WAITING' });
                })
                .catch((err) => console.warn('Service Worker 登録失敗:', err));
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                window.location.reload();
            });
        }
    </script>
</body>
</html>
